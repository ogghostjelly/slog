<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>slog alloca</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            margin: 8%;
        }

        a:hover {
            background: linear-gradient(to right, #6666ff, #0099ff, #00ff00, #ff3399, #6666ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: rainbow_animation 1s ease-in-out infinite;
            background-size: 400% 100%;
            filter: drop-shadow(red 0px 0px 2px);
        }

        a:active {
            filter: drop-shadow(blue 0px 0px 2px);
        }

        @keyframes rainbow_animation {

            0%,
            100% {
                background-position: 0 0;
            }

            50% {
                background-position: 100% 0;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>alloca in Rust using inline ASM</h1>
    </header>
    <a href="index.html">go back</a>
    <main>
        <p>
            warning! this is an evolving document (well technically this entire site is but...). I'm still writing it
            and it doesn't explain certain things very well. SORRY!
        </p>

        <h2>inception</h2>
        <p>
            The stack is like a stack of plates. You can't change things in the middle or the
            whole thing falls down and you need to know the size of plates you want to
            remove. Usually the sizes are known at compile-time, but we can store variable-size data on the stack by
            keeping track of the size so we know how much to pop.
        </p>

        In C there is an <a href="https://www.man7.org/linux/man-pages/man3/alloca.3.html"><code>alloca</code></a>
        function that can allocate variable-size data, but no one really talks about it because it's <a
            href="https://stackoverflow.com/questions/1018853/why-is-the-use-of-alloca-not-considered-good-practice">bad
            practice</a>!
        But hold on, that function doesn't exist in the Rust std library!
        There <i>is</i> <a href="https://docs.rs/alloca/latest/alloca/">a library</a>
        that implements alloca in Rust but it just
        links to C which is no fun. We want alloca in <b>Pure Rustâ„¢</b>.

        <h2>learning asm</h2>

        <p>
            Here's what we're going to do. We're going to move the stack pointer down to allocate some space, and then
            we're going to move the stack pointer back up to deallocate the space. Pretty crazy stuff right. (Remember
            the stack grows downwards)
        </p>

        <code><pre>
unsafe {
    asm!("sub rsp, 8"); // allocate 8 bytes
    my_function();
    asm!("add rsp, 8"); // deallocate 8 bytes
}
        </pre></code>

        Looks good! Or does it... Let's look at the Rust reference book, specifically
        <a href="https://doc.rust-lang.org/reference/inline-assembly.html#r-asm.register-names.not-for-io">
            the part for registers in inline assmebly.
        </a>

        <br><br><q>
            The stack pointer must be restored to its original value at the end of the <code>asm!</code> code block
        </q><br><br>

        <p>
            Hmm, that's definitely going to be a problem. If you look back up at the code we wrote you can see the stack
            pointer isn't restored at the end of the <code>asm!("sub rsp, 8")</code> block.
            That's going to cause weird bugs and undefined behaviour if we aren't careful.
        </p>

        Ok, but what if we just put it in one block.

        <code><pre>
unsafe {
    asm!(
        "sub rsp, 8",
        "add rsp, 8",
    )
}
        </pre></code>

        <p>
            Perfect! Now we've allocated and deallocated stack memory, but how do we actually use it?
            As soon as the block exits, the stack memory is already deallocated, that's not very useful.
        </p>

        <p>
            Let's make the assembly call a function! To call a function in assembly we can use the <code>call</code>
            instruction.
        </p>

        <code><pre>
unsafe {
    extern "C" fn my_function() {}

    asm! {
        "sub rsp, 8",
        "call {f}",
        "add rsp, 8",

        f = in(reg) my_function,
    }
}
        </pre></code>

        <p>
            We have to specify the function pointer as an input register with <code>f = in(reg) my_function</code>.
            You can <a href="https://doc.rust-lang.org/reference/inline-assembly.html#operand-type">find more
                information about setting input/output registers in the Rust reference book.</a>
            But basically, you tell the compiler what the asm block receives with <code>in(reg)</code> and what it
            returns with <code>out(reg)</code>.
        </p>

        <p>
            Ok I lied, it isn't *that* easy to call a function in assembly. First of all, on certain CPU
            architectures
            the stack pointer has to be a multiple of 16 before we jump to a function (known as stack-alignment). And
            second of all, we need to tell the compiler what registers our code modifies (known as register
            clobbering).
        </p>

        <p>
            Since we are calling an <code>extern "C"</code> function, we are going to be clobbering any registers that
            the <code>extern "C"</code> function would. We can tell the compiler that we are clobbering registers in a C
            way with the <code>clobber_abi("C")</code> flag. Let's change the stack pointer to be a multiple of 16 too.
        </p>

        <code><pre>
unsafe {
    extern "C" fn my_function() {}

    asm! {
        "sub rsp, 16", // change to 16
        "call {f}",
        "add rsp, 16", // change to 16

        f = in(reg) my_function,
        clobber_abi("C"), // specify C ABI
    }
}
        </pre></code>

        <p>
            Now we are correctly telling the compiler what registers get clobbered and we are ensuring the stack pointer
            is a multiple of 16. Great!
        </p>

        <p>
            There is still an issue though... we still can't use our allocated data! The function has no parameters! It
            needs to take a pointer to the data we allocated so that we can use it.
        </p>

        <p>
            In the C ABI the first parameter of a function is passed in the <code>rdi</code> register.
            So let's set the <code>rdi</code> register to a pointer so that the function can use it.
        </p>

        <code><pre>
unsafe {
    extern "C" fn my_function(ptr: *mut c_void) {}

    asm! {
        "sub rsp, 16",
        "mov rdi, rsp", // set first parameter to rsp
        "call {f}",
        "add rsp, 16",

        f = in(reg) my_function,
        clobber_abi("C"),
    }
}
        </pre></code>

        <p>
            And that's it! Assembly is wildly unsafe, especially because Rust expects your program to "follow all the
            rules".
            There are likely tons of edge-cases I missed that would cause weird obscure <a
                href="https://en.wikipedia.org/wiki/Heisenbug">heisenbugs</a>. I really wouldn't use
            this in
            production code but it is a fun exercise. I hope you learnt something reading this because I learnt a lot
            making
            it.
        </p>

        <h2>final thoughts</h2>

        <p>
            There's one detail I didn't cover and that's making alloca work for any closure and not just
            <code>extern "C"</code> functions.
            You can see the full source code <a href="https://github.com/ogghostjelly/alloca-shenanigans/">here</a>.
            I made this a while ago but I thought I may aswell turn it into a blog post.
        </p>

        <p>
            P.S If you find any of those aforementioned edge-cases that I missed, shoot me a message
            <a href="mailto:johnnycambodia09@gmail.com">johnnycambodia09@gmail.com</a>
        </p>
    </main>
</body>

</html>